# RISC-V Toolchain Conventions

## Copyright and license information

This document is authored by:
* Alex Bradbury <asb@lowrisc.org>.

Licensed under the Creative Commons Attribution 4.0 International License 
(CC-BY 4.0). The full license text is available at 
https://creativecommons.org/licenses/by/4.0/.

## Aims

This effort aims to document the expected behaviour and command-line interface 
of RISC-V toolchains. In doing so, we can provide an avenue for members of the 
GNU and LLVM communities to collaborate on standardising and extending these 
conventions. A diverse range of RISC-V implementations and custom extensions 
will inevitably result in vendor-specific toolchains being created and 
distributed. By describing a clear preferred path for exposing vendor-specific 
extensions or modifications, we can try to increase the likelihood that these 
vendor toolchain distributions have a common interface and aren't gratuitously 
different.

## Status and roadmap

This document is a work-in-progress, and contains many sections that serve 
mainly to enumerate current gaps or oddities. The plan is to seek feedback and 
further develop the proposal with the help of the RISC-V community, then to 
seek input from the wider GCC and Clang developer communities for extensions 
or changes beyond the current set of command-line options supported by GCC.

See the [issues 
list](https://github.com/riscv-non-isa/riscv-toolchain-conventions/issues) to 
discuss any of the problems or TODO items described in this document.

This document is currently targeted at toolchain implementers and developers, 
but over time we hope it will also become a useful reference for RISC-V 
toolchain users.

## See also
* [RISC-V user-level ISA specification](https://riscv.org/technical/specifications/)
  (Document Version 20191213)
* [RISC-V ELF psABI 
specification](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc)
* [RISC-V Assembly Programmer's 
Manual](https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md)
* [GCC RISC-V option 
documentation](https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html)

## Specifying the target ISA with `-march` and `-misa-spec`

The compiler and assembler both accept the `-march` flag to specify the target
ISA. Additionally, the `-misa-spec` flag allows specifying the ISA specification
release, which can have a subtle difference on how the string provided to the
`-march` flag is interpreted.

The `-march` string can be defined using one of the following formats:
1) using the ISA-string-based format, or
2) using the profile-based format.

Both formats allow specifying a list of extensions that form an additive set.

### ISA-string-based format

The ISA-string-based format looks similar to ISA naming strings as specified
in the ISA Extension Naming Conventions chapter of the RISC-V ISA
specification.

A valid `-march` string in the ISA-string-based format must follow these rules:

* All characters of the string must be lowercase.
* The first part of the string must be `rv32`, `rv64`, or `rv128` followed by
  the base integer ISA (`i`, or `e`).  As `g` implies `i`, this letter can
  also be used.
* The next part consists of single-letter and multi-letter ISA extensions,
  which may be in non-canonical order.
* Single-letter ISA extensions may be separated from other single-letter extensions
  by an underscore (`_`).
* Multi-letter ISA extensions must be separated from other extensions
  by an underscore (`_`).
* Versioning of extensions follows the ISA naming string rules (e.g. `zba1p0`).
  Single-letter extensions with versioning are still considered single-letter
  extensions (`m1p0` is considered a single-letter extension).
* ISA extensions can be versioned the same way as in ISA naming strings
  (appending it directly to the ISA extension name and separate the major
  from the minor version number using a `p`).
  E.g. `m1p0` represents `m` in version `1.0`.
  The selected version in case the extension's version number is not specified
  as part of the `-march` string is compiler-specific.
* The version separator(`p`) has a higher priority than a trailing `p` in the
  extension name. E.g. `zba1p` will be interpreted as `zba` version 1.0 and
  not as `zba1p`.

Examples:

* `rv32imac`: Valid `-march` string.
* `rv64gc`: Valid ISA string.
* `rv32ima_zicsr`: Valid `-march` string.
* `rv32i2p1m2p0a2p1f2p2d2p2c_zicsr_zifencei`: Valid `-march` string.
* `rv64gc_zba_zbb_zbc1p0`: Valid `-march` string.
* `rv64gc_xtheadba`: Valid `-march` string.
* `rv32i_zicsr_mafd`: Valid `-march` string.
* `rv32i_mafd_zicsr`: Valid `-march` string.
* `rv32i_m_a_f_d_zicsr`: Valid `-march` string.
* `rv32i_mafdzicsr`: Invalid because `mafdzicsr` does not separate the multi-letter extension `Zicsr`.
* `rv64gc_Zicsr`: Invalid because of the uppercase character.
* `rv32mai`: Invalid because base ISA does not follow `rv32`.
* `rv32i_zicsrzifencei`: Invalid because multi-letter extensions need to be
   separated by an underscore (`zicsr` and `zifencei` are existing individual
   extensions).

NOTE: A RISC-V ISA extension might depend on other ISA extensions.
This dependencies are honored by the `-march` string.
E.g. `D` implies `F` and does not need to be listed explicitly.

NOTE: The ISA-string-based format is a user-friendly format,
that is different from the machine-friendly format in the ELF
tag `Tag_RISCV_arch`.

#### Interpretation versioning with `-misa-spec`

The interpretation of the string provided to the `-march` flag
in ISA-string-based format is versioned using the `-misa-spec` flag.
The `-misa-spec` flag is incompatible with a string provided
to the `-march` flag in the profile-based format.

Possible versions are:

* `2.2`
* `20190608`
* `20191213`

Additional versions might appear in the future if a change of
the interpretation is required.

The following interpretation differences exist:

* The expansion of `g` with versions before `20190608` is `imafd`.
  The expansion of `g` with version `20190609` or later is
  `imafd_zicsr_zifencei`.

Examples:

* `-march=rv64gc -misa-spec=20191213` enables RV64I and the extensions
  `mafdc` as well as `zicsr` and `zifencei`.
* `-march=rv64gc -misa-spec=rva22` is invalid (unknown ISA version).

NOTE: The RISC-V specification is intended to be backward and
forward-compatible. However, such a goal is usually hard to achieve and fixes
for mistakes in specifications or misinterpretation of specifications
may require differences in how the `-march` string is interpreted.
The required changes are subtle and irrelevant to most users.
However, a mechanism to enable old behavior (even if considered wrong)
is considered a helpful solution for users that depend on this behavior.

### Profile-based format

The profiles-string-based format has the following form
`-march=<profile-name>[+<option-ext>]+`.

Profile names are lowercase strings of the profile name (e.g. `rva22u64`).
It is possible to add additional extensions using the `+` character.

The effect of specifying a profile is that all mandatory extensions
of that profile will be enabled. The list of mandatory extensions
of a profile can be found in the RISC-V profiles specification.

The profiles-string-based format is implicitly versioned
by the profile's prefix (e.g. "rva22"), therefore a change in the
interpretation (if necessary) can be introduced by adding support
for a new profile version. Therefore, the profiles-string-based format
is not compatible with the versioning flag `-misa-spec`.

Examples:

* `rva22u64`: Valid `-march` string.
* `rva22u64+v` Valid `-march` string.
* `rva22u64+xtheadba`: Valid `-march` string.
* `rva22u64+xventanacondopts1p0`: Valid -march string.
* `RVA22U64`: Invalid because the string must not contain uppercase characters.
* `rva22u64+zfinx` is not valid because Zfinx is incompatible with RVA22U64.
* `-march=rva22u64 -misa-spec=2.2` is not valid because the `-misa-spec`
  flag is not compatible with the profile-based format.

### Implicit effects of the `-march` string

A target `-march` string, which includes floating point instructions, implies a
hardfloat calling convention, but can be overridden using the `-mabi` flag
(see the next section).

If the `c` (compressed) instruction set extension is targeted, the compiler
will generate compressed instructions where possible.

## Specifying the target ABI with -mabi

RISC-V compilers support the following ABIs, which can be specified using 
`-mabi`:

* [`ilp32`](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc#abi-ilp32): 
  int, long, pointers are 32-bit. GPRs and the stack are used for 
  parameter passing.
* [`ilp32f`](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc#abi-ilp32f): 
  int, long, pointers are 32-bit. GPRs, 32-bit FPRs, and the stack are 
  used for parameter passing.
* [`ilp32d`](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc#abi-ilp32d): 
  int, long, pointers are 32-bit. GPRs, 64-bit FPRs and the stack are 
  used for parameter passing.
* [`lp64`](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc#abi-lp64): 
  long, pointers are 64-bit. GPRs and the the stack are used for 
  parameter passing.
* [`lp64f`](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc#abi-lp64f): 
  long, pointers are 64-bit. GPRs, 32-bit FPRs, and the stack are used for 
  parameter passing.
* [`lp64d`](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc#abi-lp64d): 
  long, pointers are 64-bit. GPRs, 64-bit FPRs, and the stack are used for 
  parameter passing.

See the [RISC-V ELF 
psABI](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc) 
for more information on these ABIs.

The default value for `-mabi` is system dependent. For cross-compilation, both
`-march` and `-mabi` should be specified. An error will be produced for
impossible combinations of `-march` and `-mabi` such as `-march=rv32i` and
`-mabi=ilp32f`.

### Issues for consideration
* Should the `-mabi` string be parsed case insensitively?
* How should the RV32E ABI be specified? `ilp32e`?

## Specifying the target code model with -mcmodel

The target code model indicates constraints on symbols which the compiler can 
exploit these constraints to generate more efficient code. Two code models are 
currently defined for RISC-V:

* `-mcmodel=medlow`. The program and its statically defined symbols must lie 
within a single 2GiB address range, between the absolute addresses -2GiB and 
+2GiB. `lui` and `addi` pairs are used to generate addresses.
* `-mcmodel=medany`. The program and its statically defined symbols must lie 
within a single 4GiB address range. `auipc` and `addi` pairs are used to 
generate addresses.

TODO: interaction with PIC.

### Issues for consideration
* It has been proposed to deprecate the `medlow` code model and rename 
`medany` to `medium`.

## Disassembler (objdump) behaviour

A RISC-V ELF binary is not currently self-describing, in the sense that it 
doesn't contain enough information to determine which variant of the RISC-V 
architecture is being targeted. GNU objdump will currently attempt disassemble 
any instruction whose encoding matches one of the standard RV32/RV64GC 
extensions.

objdump will default to showing pseudoinstructions and ABI register names. The 
`numeric` disassembler argument can be used to use architectural register 
names such as `x10`, while the `no-aliases` disassembler argument will ensure 
only canonical instructions rather than pseudoinstructions or aliases are 
printed. These arguments are specified using `-M`, e.g. `-M numeric` or `-M 
numeric,no-aliases`.

Perhaps surprisingly, the disassembler will default to hiding the difference 
between compressed (16-bit) instructions and their 32-bit equivalent. e.g.
`c.addi sp, -16` will be printed as `addi sp, sp, -16`.

### Issues for consideration
* The current GNU objdump behaviour will not provide useful results for cases 
where non-standard extensions are implemented which reuse some of the standard 
extension's encoding space. Making RISC-V ELF files self-describing (as 
discussed [here](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/pull/47)) would 
avoid this problem.
* Would it be useful to have separate flags that control the printing of 
pseudoinstructions and whether compressed instructions are printed directly or 
not?

## Assembler behaviour

See the [RISC-V Assembly Programmer's 
Manual](https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md) 
for details on the syntax accepted by the assembler.

The assembler will produce compressed instructions whenever possible if the 
targeted RISC-V variant includes support for the 'C' compressed instruction 
set.

### Issues for consideration
* There is currently no way to enable support for the 'C' ISA extension, but to 
disable the automatic 'compression' of instructions.

## C/C++ preprocessor definitions

* `__riscv`: defined for any RISC-V target. Older versions of the GCC 
toolchain defined `__riscv__`.
* `__riscv_xlen`: 32 for RV32 and 64 for RV64.
* `__riscv_float_abi_soft`, `__riscv_float_abi_single`, 
`__riscv_float_abi_double`: one of these three will be defined, depending on 
target ABI.
* `__riscv_cmodel_medlow`, `__riscv_cmodel_medany`: one of these two will be 
defined, depending on the target code model.
* `__riscv_mul`: defined when targeting the 'M' ISA extension.
* `__riscv_muldiv`: defined when targeting the 'M' ISA extension and 
`-mno-div` has not been used.
* `__riscv_div`: defined when targeting the 'M' ISA extension and `-mno-div` 
has not been used.
* `__riscv_atomic`: defined when targeting the 'A' ISA extension.
* `__riscv_flen`: 32 when targeting the 'F' ISA extension (but not 'D') and 64 
when targeting 'FD'.
* `__riscv_fdiv`: defined when targeting the 'F' or 'D' ISA extensions and 
`-mno-fdiv` has not been used.
* `__riscv_fsqrt`: defined when targeting the 'F' or 'D' ISA extensions and 
`-mno-fdiv` has not been used.
* `__riscv_compressed`: defined when targeting the 'C' ISA extension.

### Issues for consideration
* What should the naming convention be for defines that indicate support for 
non-standard extensions?
* What additional information could/should be exposed via preprocessor 
defines?

## Specifying stack alignment

The default stack alignment is 16 bytes in RV32I and RV64I, and 4 bytes on 
RV32E. There is not currently a way to specify an alternative stack alignment, 
but the `-mpreferred-stack-boundary` and `-mincoming-stack-boundary` flags 
supported by GCC on X86 could be adopted.

## Save restore support

The save restore optimization is enabled through the option `-msave-restore`
and reduces the amount of code in the prologue and epilogue by using
library functions instead of inline code to save and restore callee saved
registers. The library functions are provided in the emulation library and
have the following signatures:

* `void __riscv_save_<N>(void)`
* `void __riscv_restore_<N>(void)`
* `void __riscv_restore_tailcall_<N>(void *tail /* passed in t1 */)` (LLVM/compiler-rt only)

`<N>` is a value between 0 and 12 and corresponds to the number of
registers between `s0` and `s11` that are saved/restored. The return
address register `ra` is always included in the registers saved and restored.

The `__riscv_save_<N>` functions are called from the prologue, using `t0` as
the link register to avoid clobbering `ra`. They allocate stack space for the
registers and then save `ra` and the appropriate number of registers from
`s0`-`s11`. The `__riscv_restore_<N>` functions are tail-called from the
epilogue. They restore the saved registers, deallocate the stack space for the
register, and then perform a return through the restored value of `ra`.

`__riscv_restore_tailcall_<N>` are additional entry points used when the
epilogue of the called function ends in a tail-call. Unlike
`__riscv_restore_<N>` these are also provided the address of the function
which was originally tail-called as an argument, and after restoring
registers they make a tail-call through that argument instead of returning.
Note that the address of the function to tail-call is provided in register `t1`,
which differs from the normal calling convention.

As of November 2021 the additional tail-call entry points are only
implemented in compiler-rt, and calls will only be generated by LLVM
when the option `-mllvm -save-restore-tailcall` is specified.

## Conventions for vendor extensions

Support for custom instruction set extensions are an important part of RISC-V,
with large encoding spaces reserved of vendor extensions.

However, there are no official guidelines on naming the mnemonics. This section
defines guidelines which vendors are expected to follow if upstreaming support
for their extensions. Although vendor-provided toolchains are free to make
different choices, they are strongly urged to align with these guidelines in
order to ensure there is a straightforward path for upstreaming in the future.

NOTE: Open source toolchain maintainer has final say on accepting vendor
extension, comply with this conventions isn't guarantee upstream will accept.

### Vendor extension naming scheme

According to the RISC-V ISA spec, non-standard extensions are named using a single `X`
followed by an alphabetical name and an optional version number.

To make it easier to identify and prevent naming conflict, vendor extensions
should start with a vendor name, which could be an abbreviation of the full name.

For example:
- `XVentanaCondOps` from Ventana
- `Xsfcflushdlone` from SiFive

### Assembly mnemonic

In order to avoid confusion between standard extension and other vendor
extensions, instruction mnemonics from vendor extensions must have a
prefix corresponding to the vendor's name.

The vendor prefix should be at least two letters long

e.g. `sf.` for SiFive, `vt.` for Ventana. No central registration with RISC-V
International or elsewhere is required before the prefix is used.

NOTE: Although no centralized registration is required, vendors should add the
vendor prefix to the table *IF* vendors are interested to upstream their
extension to open source toolchain like LLVM or GNU toolchain.

Vendors should also aim to follow the conventions used for naming mnemonics
in the ratified base ISA and extensions (e.g. the use of 'w', 'd',
'u', and 's' suffixes).

### List of vendor prefixes


Vendor                 | Prefix          | URL
:--------------------- | :-------------- | :-------------
SiFive                 | sf              | https://www.sifive.com/
T-Head                 | th              | https://www.t-head.cn/
Ventana Micro Systems  | vt              | https://www.ventanamicro.com/

NOTE: Vendor prefixes are case-insensitive.

### List of vendor extensions

Vendor  | Name            | Version        | ISA Document
:------ | :-------------- | :------------- | :---------------
T-Head  | XTheadCmo       | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadSync      | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadBa        | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadBb        | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadBs        | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadCondMov   | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadMac       | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadMemPair   | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadMemIdx    | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
T-Head  | XTheadFMemIdx   | 2.0.0          | [T-Head ISA extension specification](https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.0.0/xthead-2022-09-05-2.0.0.pdf)
Ventana | XVentanaCondOps | 1.0            | [VTx-family custom instructions](https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf)

NOTE: Vendor extension names are case-insensitive, CamelCase is used here
for readability.

## TODO

* `-mdiv`, `-mno-div`, `-mfdiv`, `-mno-fdiv`, `-msave-restore`, 
  `-mno-save-restore`, `-mstrict-align`, `-mno-strict-align`, 
  `-mexplicit-relocs`, `-mno-explicit-relocs`

## Appendix: Exposing a vendor-specific extension across the toolchain

TODO.
